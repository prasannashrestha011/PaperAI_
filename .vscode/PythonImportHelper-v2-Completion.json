[
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypedDict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Container",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TextIO",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Container",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "BaseMessage",
        "importPath": "langchain_core.messages",
        "description": "langchain_core.messages",
        "isExtraImport": true,
        "detail": "langchain_core.messages",
        "documentation": {}
    },
    {
        "label": "create_agent",
        "importPath": "langchain.agents",
        "description": "langchain.agents",
        "isExtraImport": true,
        "detail": "langchain.agents",
        "documentation": {}
    },
    {
        "label": "RunnableConfig",
        "importPath": "langchain_core.runnables",
        "description": "langchain_core.runnables",
        "isExtraImport": true,
        "detail": "langchain_core.runnables",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "asyncio",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "asyncio",
        "description": "asyncio",
        "detail": "asyncio",
        "documentation": {}
    },
    {
        "label": "InMemorySaver",
        "importPath": "langgraph.checkpoint.memory",
        "description": "langgraph.checkpoint.memory",
        "isExtraImport": true,
        "detail": "langgraph.checkpoint.memory",
        "documentation": {}
    },
    {
        "label": "spacy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "spacy",
        "description": "spacy",
        "detail": "spacy",
        "documentation": {}
    },
    {
        "label": "partition_pdf",
        "importPath": "unstructured.partition.pdf",
        "description": "unstructured.partition.pdf",
        "isExtraImport": true,
        "detail": "unstructured.partition.pdf",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "ChatPromptTemplate",
        "importPath": "langchain_core.prompts",
        "description": "langchain_core.prompts",
        "isExtraImport": true,
        "detail": "langchain_core.prompts",
        "documentation": {}
    },
    {
        "label": "RecursiveCharacterTextSplitter",
        "importPath": "langchain_text_splitters",
        "description": "langchain_text_splitters",
        "isExtraImport": true,
        "detail": "langchain_text_splitters",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "AsyncGraphDatabase",
        "importPath": "neo4j",
        "description": "neo4j",
        "isExtraImport": true,
        "detail": "neo4j",
        "documentation": {}
    },
    {
        "label": "AsyncSession",
        "importPath": "neo4j",
        "description": "neo4j",
        "isExtraImport": true,
        "detail": "neo4j",
        "documentation": {}
    },
    {
        "label": "Graph",
        "importPath": "py2neo",
        "description": "py2neo",
        "isExtraImport": true,
        "detail": "py2neo",
        "documentation": {}
    },
    {
        "label": "json,re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json.re",
        "description": "json.re",
        "detail": "json.re",
        "documentation": {}
    },
    {
        "label": "ChatGoogleGenerativeAI",
        "importPath": "langchain_google_genai",
        "description": "langchain_google_genai",
        "isExtraImport": true,
        "detail": "langchain_google_genai",
        "documentation": {}
    },
    {
        "label": "GoogleGenerativeAIEmbeddings",
        "importPath": "langchain_google_genai",
        "description": "langchain_google_genai",
        "isExtraImport": true,
        "detail": "langchain_google_genai",
        "documentation": {}
    },
    {
        "label": "ChatOpenAI",
        "importPath": "langchain_openai",
        "description": "langchain_openai",
        "isExtraImport": true,
        "detail": "langchain_openai",
        "documentation": {}
    },
    {
        "label": "ChatOllama",
        "importPath": "langchain_ollama",
        "description": "langchain_ollama",
        "isExtraImport": true,
        "detail": "langchain_ollama",
        "documentation": {}
    },
    {
        "label": "OllamaEmbeddings",
        "importPath": "langchain_ollama",
        "description": "langchain_ollama",
        "isExtraImport": true,
        "detail": "langchain_ollama",
        "documentation": {}
    },
    {
        "label": "ChatGroq",
        "importPath": "langchain_groq",
        "description": "langchain_groq",
        "isExtraImport": true,
        "detail": "langchain_groq",
        "documentation": {}
    },
    {
        "label": "OpenAIEmbeddings",
        "importPath": "langchain_openai.embeddings",
        "description": "langchain_openai.embeddings",
        "isExtraImport": true,
        "detail": "langchain_openai.embeddings",
        "documentation": {}
    },
    {
        "label": "HuggingFaceEmbeddings",
        "importPath": "langchain_huggingface",
        "description": "langchain_huggingface",
        "isExtraImport": true,
        "detail": "langchain_huggingface",
        "documentation": {}
    },
    {
        "label": "ChatDeepSeek",
        "importPath": "langchain_deepseek",
        "description": "langchain_deepseek",
        "isExtraImport": true,
        "detail": "langchain_deepseek",
        "documentation": {}
    },
    {
        "label": "Document",
        "importPath": "langchain_core.documents",
        "description": "langchain_core.documents",
        "isExtraImport": true,
        "detail": "langchain_core.documents",
        "documentation": {}
    },
    {
        "label": "Document",
        "importPath": "langchain_core.documents",
        "description": "langchain_core.documents",
        "isExtraImport": true,
        "detail": "langchain_core.documents",
        "documentation": {}
    },
    {
        "label": "tool",
        "importPath": "langchain_core.tools",
        "description": "langchain_core.tools",
        "isExtraImport": true,
        "detail": "langchain_core.tools",
        "documentation": {}
    },
    {
        "label": "BaseTool",
        "importPath": "langchain_core.tools",
        "description": "langchain_core.tools",
        "isExtraImport": true,
        "detail": "langchain_core.tools",
        "documentation": {}
    },
    {
        "label": "op",
        "importPath": "alembic",
        "description": "alembic",
        "isExtraImport": true,
        "detail": "alembic",
        "documentation": {}
    },
    {
        "label": "op",
        "importPath": "alembic",
        "description": "alembic",
        "isExtraImport": true,
        "detail": "alembic",
        "documentation": {}
    },
    {
        "label": "context",
        "importPath": "alembic",
        "description": "alembic",
        "isExtraImport": true,
        "detail": "alembic",
        "documentation": {}
    },
    {
        "label": "sqlalchemy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "engine_from_config",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "pool",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "MetaData",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "Column",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "UUID",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "String",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "fileConfig",
        "importPath": "logging.config",
        "description": "logging.config",
        "isExtraImport": true,
        "detail": "logging.config",
        "documentation": {}
    },
    {
        "label": "create_async_engine",
        "importPath": "sqlalchemy.ext.asyncio",
        "description": "sqlalchemy.ext.asyncio",
        "isExtraImport": true,
        "detail": "sqlalchemy.ext.asyncio",
        "documentation": {}
    },
    {
        "label": "AsyncSession",
        "importPath": "sqlalchemy.ext.asyncio",
        "description": "sqlalchemy.ext.asyncio",
        "isExtraImport": true,
        "detail": "sqlalchemy.ext.asyncio",
        "documentation": {}
    },
    {
        "label": "AsyncSession",
        "importPath": "sqlalchemy.ext.asyncio",
        "description": "sqlalchemy.ext.asyncio",
        "isExtraImport": true,
        "detail": "sqlalchemy.ext.asyncio",
        "documentation": {}
    },
    {
        "label": "create_async_engine",
        "importPath": "sqlalchemy.ext.asyncio",
        "description": "sqlalchemy.ext.asyncio",
        "isExtraImport": true,
        "detail": "sqlalchemy.ext.asyncio",
        "documentation": {}
    },
    {
        "label": "AsyncSession",
        "importPath": "sqlalchemy.ext.asyncio",
        "description": "sqlalchemy.ext.asyncio",
        "isExtraImport": true,
        "detail": "sqlalchemy.ext.asyncio",
        "documentation": {}
    },
    {
        "label": "Base",
        "importPath": "database.database",
        "description": "database.database",
        "isExtraImport": true,
        "detail": "database.database",
        "documentation": {}
    },
    {
        "label": "Base",
        "importPath": "database.database",
        "description": "database.database",
        "isExtraImport": true,
        "detail": "database.database",
        "documentation": {}
    },
    {
        "label": "Base",
        "importPath": "database.models",
        "description": "database.models",
        "isExtraImport": true,
        "detail": "database.models",
        "documentation": {}
    },
    {
        "label": "User",
        "importPath": "database.models",
        "description": "database.models",
        "isExtraImport": true,
        "detail": "database.models",
        "documentation": {}
    },
    {
        "label": "APIRouter",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "Depends",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "FastAPI",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "select",
        "importPath": "sqlalchemy.future",
        "description": "sqlalchemy.future",
        "isExtraImport": true,
        "detail": "sqlalchemy.future",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "CryptContext",
        "importPath": "passlib.context",
        "description": "passlib.context",
        "isExtraImport": true,
        "detail": "passlib.context",
        "documentation": {}
    },
    {
        "label": "asyncpg",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "asyncpg",
        "description": "asyncpg",
        "detail": "asyncpg",
        "documentation": {}
    },
    {
        "label": "sessionmaker",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "declarative_base",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "uuid",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "uuid",
        "description": "uuid",
        "detail": "uuid",
        "documentation": {}
    },
    {
        "label": "logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging",
        "description": "logging",
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "os.path",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os.path",
        "description": "os.path",
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "argparse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "argparse",
        "description": "argparse",
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "ArgumentParser",
        "importPath": "argparse",
        "description": "argparse",
        "isExtraImport": true,
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "pdfminer",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pdfminer",
        "description": "pdfminer",
        "detail": "pdfminer",
        "documentation": {}
    },
    {
        "label": "PDFDocument",
        "importPath": "pdfminer.pdfdocument",
        "description": "pdfminer.pdfdocument",
        "isExtraImport": true,
        "detail": "pdfminer.pdfdocument",
        "documentation": {}
    },
    {
        "label": "PDFNoOutlines",
        "importPath": "pdfminer.pdfdocument",
        "description": "pdfminer.pdfdocument",
        "isExtraImport": true,
        "detail": "pdfminer.pdfdocument",
        "documentation": {}
    },
    {
        "label": "PDFXRefFallback",
        "importPath": "pdfminer.pdfdocument",
        "description": "pdfminer.pdfdocument",
        "isExtraImport": true,
        "detail": "pdfminer.pdfdocument",
        "documentation": {}
    },
    {
        "label": "PDFIOError",
        "importPath": "pdfminer.pdfexceptions",
        "description": "pdfminer.pdfexceptions",
        "isExtraImport": true,
        "detail": "pdfminer.pdfexceptions",
        "documentation": {}
    },
    {
        "label": "PDFObjectNotFound",
        "importPath": "pdfminer.pdfexceptions",
        "description": "pdfminer.pdfexceptions",
        "isExtraImport": true,
        "detail": "pdfminer.pdfexceptions",
        "documentation": {}
    },
    {
        "label": "PDFTypeError",
        "importPath": "pdfminer.pdfexceptions",
        "description": "pdfminer.pdfexceptions",
        "isExtraImport": true,
        "detail": "pdfminer.pdfexceptions",
        "documentation": {}
    },
    {
        "label": "PDFValueError",
        "importPath": "pdfminer.pdfexceptions",
        "description": "pdfminer.pdfexceptions",
        "isExtraImport": true,
        "detail": "pdfminer.pdfexceptions",
        "documentation": {}
    },
    {
        "label": "PDFValueError",
        "importPath": "pdfminer.pdfexceptions",
        "description": "pdfminer.pdfexceptions",
        "isExtraImport": true,
        "detail": "pdfminer.pdfexceptions",
        "documentation": {}
    },
    {
        "label": "PDFPage",
        "importPath": "pdfminer.pdfpage",
        "description": "pdfminer.pdfpage",
        "isExtraImport": true,
        "detail": "pdfminer.pdfpage",
        "documentation": {}
    },
    {
        "label": "PDFParser",
        "importPath": "pdfminer.pdfparser",
        "description": "pdfminer.pdfparser",
        "isExtraImport": true,
        "detail": "pdfminer.pdfparser",
        "documentation": {}
    },
    {
        "label": "PDFObjRef",
        "importPath": "pdfminer.pdftypes",
        "description": "pdfminer.pdftypes",
        "isExtraImport": true,
        "detail": "pdfminer.pdftypes",
        "documentation": {}
    },
    {
        "label": "PDFStream",
        "importPath": "pdfminer.pdftypes",
        "description": "pdfminer.pdftypes",
        "isExtraImport": true,
        "detail": "pdfminer.pdftypes",
        "documentation": {}
    },
    {
        "label": "resolve1",
        "importPath": "pdfminer.pdftypes",
        "description": "pdfminer.pdftypes",
        "isExtraImport": true,
        "detail": "pdfminer.pdftypes",
        "documentation": {}
    },
    {
        "label": "stream_value",
        "importPath": "pdfminer.pdftypes",
        "description": "pdfminer.pdftypes",
        "isExtraImport": true,
        "detail": "pdfminer.pdftypes",
        "documentation": {}
    },
    {
        "label": "LIT",
        "importPath": "pdfminer.psparser",
        "description": "pdfminer.psparser",
        "isExtraImport": true,
        "detail": "pdfminer.psparser",
        "documentation": {}
    },
    {
        "label": "PSKeyword",
        "importPath": "pdfminer.psparser",
        "description": "pdfminer.psparser",
        "isExtraImport": true,
        "detail": "pdfminer.psparser",
        "documentation": {}
    },
    {
        "label": "PSLiteral",
        "importPath": "pdfminer.psparser",
        "description": "pdfminer.psparser",
        "isExtraImport": true,
        "detail": "pdfminer.psparser",
        "documentation": {}
    },
    {
        "label": "isnumber",
        "importPath": "pdfminer.utils",
        "description": "pdfminer.utils",
        "isExtraImport": true,
        "detail": "pdfminer.utils",
        "documentation": {}
    },
    {
        "label": "AnyIO",
        "importPath": "pdfminer.utils",
        "description": "pdfminer.utils",
        "isExtraImport": true,
        "detail": "pdfminer.utils",
        "documentation": {}
    },
    {
        "label": "pdfminer.high_level",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pdfminer.high_level",
        "description": "pdfminer.high_level",
        "detail": "pdfminer.high_level",
        "documentation": {}
    },
    {
        "label": "LAParams",
        "importPath": "pdfminer.layout",
        "description": "pdfminer.layout",
        "isExtraImport": true,
        "detail": "pdfminer.layout",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "BadZipFile",
        "importPath": "zipfile",
        "description": "zipfile",
        "isExtraImport": true,
        "detail": "zipfile",
        "documentation": {}
    },
    {
        "label": "ZipFile",
        "importPath": "zipfile",
        "description": "zipfile",
        "isExtraImport": true,
        "detail": "zipfile",
        "documentation": {}
    },
    {
        "label": "auth_router",
        "importPath": "api.auth",
        "description": "api.auth",
        "isExtraImport": true,
        "detail": "api.auth",
        "documentation": {}
    },
    {
        "label": "Neo4jRAGSystem",
        "kind": 6,
        "importPath": "server.agent.agent",
        "description": "server.agent.agent",
        "peekOfCode": "class Neo4jRAGSystem:\n    def __init__(self, user_id, document_id, provider, model):\n        self.user_id = user_id\n        self.document_id = document_id\n        self.session_id = f\"{user_id}-{document_id}\"\n        self.provider = provider \n        self.model = model\n        self.llm = ModelFactory.create_chat_model(provider=provider, model_name=model, temperature=0.3)\n        self.agent_executor = self._create_agent()\n    def _create_agent(self):",
        "detail": "server.agent.agent",
        "documentation": {}
    },
    {
        "label": "clean_text",
        "kind": 2,
        "importPath": "server.agent.builder",
        "description": "server.agent.builder",
        "peekOfCode": "def clean_text(text: str) -> str:\n    text = text.replace(\"“\", '\"').replace(\"”\", '\"').replace(\"‘\", \"'\").replace(\"’\", \"'\")\n    return text\ndef extract_text_from_pdf(pdf_path: str, quality: str) -> str:\n    \"\"\"Extraction using unstructured: returns a single string with page markers\"\"\"\n    elements = partition_pdf(\n        filename=pdf_path,\n        strategy=\"hi_res\" if quality == \"H\" else \"fast\",\n        infer_table_structure=True if quality == \"H\" else False,\n        languages=['english']  ",
        "detail": "server.agent.builder",
        "documentation": {}
    },
    {
        "label": "extract_text_from_pdf",
        "kind": 2,
        "importPath": "server.agent.builder",
        "description": "server.agent.builder",
        "peekOfCode": "def extract_text_from_pdf(pdf_path: str, quality: str) -> str:\n    \"\"\"Extraction using unstructured: returns a single string with page markers\"\"\"\n    elements = partition_pdf(\n        filename=pdf_path,\n        strategy=\"hi_res\" if quality == \"H\" else \"fast\",\n        infer_table_structure=True if quality == \"H\" else False,\n        languages=['english']  \n    )\n    pages = {}\n    # Group text by page",
        "detail": "server.agent.builder",
        "documentation": {}
    },
    {
        "label": "nlp",
        "kind": 5,
        "importPath": "server.agent.builder",
        "description": "server.agent.builder",
        "peekOfCode": "nlp = spacy.load(\"en_core_web_sm\")\ndef clean_text(text: str) -> str:\n    text = text.replace(\"“\", '\"').replace(\"”\", '\"').replace(\"‘\", \"'\").replace(\"’\", \"'\")\n    return text\ndef extract_text_from_pdf(pdf_path: str, quality: str) -> str:\n    \"\"\"Extraction using unstructured: returns a single string with page markers\"\"\"\n    elements = partition_pdf(\n        filename=pdf_path,\n        strategy=\"hi_res\" if quality == \"H\" else \"fast\",\n        infer_table_structure=True if quality == \"H\" else False,",
        "detail": "server.agent.builder",
        "documentation": {}
    },
    {
        "label": "Entity_Relation_Extractor",
        "kind": 6,
        "importPath": "server.agent.extractor",
        "description": "server.agent.extractor",
        "peekOfCode": "class Entity_Relation_Extractor:\n    \"\"\"Extract high-quality relationships with proper relations\"\"\"\n    def __init__(self, nlp_model, use_llm: bool = True,provider:str=\"gemini\",model:str=\"gemini-2.5-flash\"):\n        self.nlp = nlp_model\n        self.use_llm = use_llm\n        self.llm = None\n        try:\n            self.llm = ModelFactory.create_chat_model(provider,model,0.3)\n            print(\"✓ LLM initialized for extraction\\n\")\n        except Exception as e:",
        "detail": "server.agent.extractor",
        "documentation": {}
    },
    {
        "label": "NEO4J_URI",
        "kind": 5,
        "importPath": "server.agent.graph_config",
        "description": "server.agent.graph_config",
        "peekOfCode": "NEO4J_URI = os.getenv(\"NEO4J_URI\")\nNEO4J_USER = os.getenv(\"NEO4J_USER\")\nNEO4J_PASSWORD = os.getenv(\"NEO4J_PASSWORD\")\nGOOGLE_API_KEY = os.getenv(\"GOOGLE_API_KEY\")\ndriver = AsyncGraphDatabase.driver(NEO4J_URI, auth=(NEO4J_USER, NEO4J_PASSWORD))",
        "detail": "server.agent.graph_config",
        "documentation": {}
    },
    {
        "label": "NEO4J_USER",
        "kind": 5,
        "importPath": "server.agent.graph_config",
        "description": "server.agent.graph_config",
        "peekOfCode": "NEO4J_USER = os.getenv(\"NEO4J_USER\")\nNEO4J_PASSWORD = os.getenv(\"NEO4J_PASSWORD\")\nGOOGLE_API_KEY = os.getenv(\"GOOGLE_API_KEY\")\ndriver = AsyncGraphDatabase.driver(NEO4J_URI, auth=(NEO4J_USER, NEO4J_PASSWORD))",
        "detail": "server.agent.graph_config",
        "documentation": {}
    },
    {
        "label": "NEO4J_PASSWORD",
        "kind": 5,
        "importPath": "server.agent.graph_config",
        "description": "server.agent.graph_config",
        "peekOfCode": "NEO4J_PASSWORD = os.getenv(\"NEO4J_PASSWORD\")\nGOOGLE_API_KEY = os.getenv(\"GOOGLE_API_KEY\")\ndriver = AsyncGraphDatabase.driver(NEO4J_URI, auth=(NEO4J_USER, NEO4J_PASSWORD))",
        "detail": "server.agent.graph_config",
        "documentation": {}
    },
    {
        "label": "GOOGLE_API_KEY",
        "kind": 5,
        "importPath": "server.agent.graph_config",
        "description": "server.agent.graph_config",
        "peekOfCode": "GOOGLE_API_KEY = os.getenv(\"GOOGLE_API_KEY\")\ndriver = AsyncGraphDatabase.driver(NEO4J_URI, auth=(NEO4J_USER, NEO4J_PASSWORD))",
        "detail": "server.agent.graph_config",
        "documentation": {}
    },
    {
        "label": "driver",
        "kind": 5,
        "importPath": "server.agent.graph_config",
        "description": "server.agent.graph_config",
        "peekOfCode": "driver = AsyncGraphDatabase.driver(NEO4J_URI, auth=(NEO4J_USER, NEO4J_PASSWORD))",
        "detail": "server.agent.graph_config",
        "documentation": {}
    },
    {
        "label": "Neo4jKnowledgeGraph",
        "kind": 6,
        "importPath": "server.agent.graph_store",
        "description": "server.agent.graph_store",
        "peekOfCode": "class Neo4jKnowledgeGraph:\n    \"\"\"Optimized Neo4j storage\"\"\"\n    def __init__(self,session_id:str):\n        self.session_id=session_id\n        self.driver=driver\n    async def initialize(self):\n        \"\"\"Initialize database\"\"\"\n        print(\"Initializing Neo4j...\")\n        async with self.driver.session() as session:\n            try:",
        "detail": "server.agent.graph_store",
        "documentation": {}
    },
    {
        "label": "parse_str_to_json",
        "kind": 2,
        "importPath": "server.agent.graph_tools",
        "description": "server.agent.graph_tools",
        "peekOfCode": "def parse_str_to_json(text: str):\n    match = re.search(r\"```json\\s*(.*?)```\", text, flags=re.DOTALL)\n    if not match:\n        raise ValueError(\"No JSON block found.\")\n    json_text = match.group(1).strip()\n    data=()\n    try:\n        return json.loads(json_text)\n    except json.JSONDecodeError as e:\n        # fallback: remove remaining line breaks or carriage returns",
        "detail": "server.agent.graph_tools",
        "documentation": {}
    },
    {
        "label": "ModelFactory",
        "kind": 6,
        "importPath": "server.agent.model_factory",
        "description": "server.agent.model_factory",
        "peekOfCode": "class ModelFactory:\n    @staticmethod\n    def create_chat_model(provider: str, model_name: str, temperature: float):\n        if provider == \"gemini\":\n            return ModelFactory._create_gemini_model(model_name, temperature)\n        elif provider == \"openai\":\n            return ModelFactory._create_openai_model(model_name, temperature)\n        elif provider == \"deepseek\":\n            return ModelFactory._create_deepseek_model(model_name, temperature)\n        elif provider == \"ollama\":",
        "detail": "server.agent.model_factory",
        "documentation": {}
    },
    {
        "label": "Embedding_Factory",
        "kind": 6,
        "importPath": "server.agent.model_factory",
        "description": "server.agent.model_factory",
        "peekOfCode": "class Embedding_Factory:\n    @staticmethod\n    def create_embedding(\n        provider: str, model: str = \"sentence-transformers/all-MiniLM-L6-v2\"\n    ):\n        if provider == \"hugging-face\":\n            embedding = HuggingFaceEmbeddings(model_name=model)\n        if provider == \"openai\":\n            embedding = OpenAIEmbeddings(model=model)\n        if provider == \"gemini\":",
        "detail": "server.agent.model_factory",
        "documentation": {}
    },
    {
        "label": "KnowledgeGraphAnswer",
        "kind": 6,
        "importPath": "server.agent.output_schema",
        "description": "server.agent.output_schema",
        "peekOfCode": "class KnowledgeGraphAnswer(TypedDict):\n    query_type: str \n    entities_found: List[str]  \n    core_definition: str \n    applications: str  \n    answer: str  \n    confidence: str  # high, medium, low\n    citation: List[str] \n    follow_up_questions:List[str]\n    answer_type:str # LLM parametric knowledge | knowledge graph source",
        "detail": "server.agent.output_schema",
        "documentation": {}
    },
    {
        "label": "nlp_model",
        "kind": 5,
        "importPath": "server.agent.test",
        "description": "server.agent.test",
        "peekOfCode": "nlp_model = spacy.load(\"en_core_web_sm\")\nasync def author_lookup():\n        \"\"\"\n        Retrieve all authors who wrote a specific paper.\n        Use this tool when you need to:\n        - Find out who wrote a paper\n        - Get author contact information (email)\n        - Get author affiliations and institutions\n        - Answer questions like \"Who are the authors of this paper?\" or \"What is the author's email?\"\n        Returns:",
        "detail": "server.agent.test",
        "documentation": {}
    },
    {
        "label": "upgrade",
        "kind": 2,
        "importPath": "server.alembic.versions.1f27ee38e551_create_user_table",
        "description": "server.alembic.versions.1f27ee38e551_create_user_table",
        "peekOfCode": "def upgrade() -> None:\n    \"\"\"Upgrade schema.\"\"\"\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.create_table('user',\n    sa.Column('id', sa.UUID(), nullable=False),\n    sa.Column('username', sa.String(), nullable=False),\n    sa.Column('password', sa.String(), nullable=False),\n    sa.PrimaryKeyConstraint('id'),\n    sa.UniqueConstraint('username')\n    )",
        "detail": "server.alembic.versions.1f27ee38e551_create_user_table",
        "documentation": {}
    },
    {
        "label": "downgrade",
        "kind": 2,
        "importPath": "server.alembic.versions.1f27ee38e551_create_user_table",
        "description": "server.alembic.versions.1f27ee38e551_create_user_table",
        "peekOfCode": "def downgrade() -> None:\n    \"\"\"Downgrade schema.\"\"\"\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.drop_index(op.f('ix_user_id'), table_name='user')\n    op.drop_table('user')\n    # ### end Alembic commands ###",
        "detail": "server.alembic.versions.1f27ee38e551_create_user_table",
        "documentation": {}
    },
    {
        "label": "upgrade",
        "kind": 2,
        "importPath": "server.alembic.versions.265fad615a25_created_user_table",
        "description": "server.alembic.versions.265fad615a25_created_user_table",
        "peekOfCode": "def upgrade() -> None:\n    \"\"\"Upgrade schema.\"\"\"\n    # ### commands auto generated by Alembic - please adjust! ###\n    pass\n    # ### end Alembic commands ###\ndef downgrade() -> None:\n    \"\"\"Downgrade schema.\"\"\"\n    # ### commands auto generated by Alembic - please adjust! ###\n    pass\n    # ### end Alembic commands ###",
        "detail": "server.alembic.versions.265fad615a25_created_user_table",
        "documentation": {}
    },
    {
        "label": "downgrade",
        "kind": 2,
        "importPath": "server.alembic.versions.265fad615a25_created_user_table",
        "description": "server.alembic.versions.265fad615a25_created_user_table",
        "peekOfCode": "def downgrade() -> None:\n    \"\"\"Downgrade schema.\"\"\"\n    # ### commands auto generated by Alembic - please adjust! ###\n    pass\n    # ### end Alembic commands ###",
        "detail": "server.alembic.versions.265fad615a25_created_user_table",
        "documentation": {}
    },
    {
        "label": "run_migrations_online",
        "kind": 2,
        "importPath": "server.alembic.env",
        "description": "server.alembic.env",
        "peekOfCode": "def run_migrations_online():\n    connectable = create_async_engine(config.get_main_option(\"sqlalchemy.url\"))\n    async def do_run_migrations():\n        async with connectable.connect() as connection:\n            await connection.run_sync(do_run_migrations_sync)\n    def do_run_migrations_sync(connection):\n        context.configure(connection=connection, target_metadata=target_metadata)\n        with context.begin_transaction():\n            context.run_migrations()\n    asyncio.run(do_run_migrations())",
        "detail": "server.alembic.env",
        "documentation": {}
    },
    {
        "label": "config",
        "kind": 5,
        "importPath": "server.alembic.env",
        "description": "server.alembic.env",
        "peekOfCode": "config = context.config\nDATABASE_URL = os.environ.get(\"DATABASE_URL\")\n# Interpret the config file for Python logging.\nfileConfig(config.config_file_name)\ntarget_metadata = Base.metadata  # use your models\n# Async run migrations\ndef run_migrations_online():\n    connectable = create_async_engine(config.get_main_option(\"sqlalchemy.url\"))\n    async def do_run_migrations():\n        async with connectable.connect() as connection:",
        "detail": "server.alembic.env",
        "documentation": {}
    },
    {
        "label": "DATABASE_URL",
        "kind": 5,
        "importPath": "server.alembic.env",
        "description": "server.alembic.env",
        "peekOfCode": "DATABASE_URL = os.environ.get(\"DATABASE_URL\")\n# Interpret the config file for Python logging.\nfileConfig(config.config_file_name)\ntarget_metadata = Base.metadata  # use your models\n# Async run migrations\ndef run_migrations_online():\n    connectable = create_async_engine(config.get_main_option(\"sqlalchemy.url\"))\n    async def do_run_migrations():\n        async with connectable.connect() as connection:\n            await connection.run_sync(do_run_migrations_sync)",
        "detail": "server.alembic.env",
        "documentation": {}
    },
    {
        "label": "target_metadata",
        "kind": 5,
        "importPath": "server.alembic.env",
        "description": "server.alembic.env",
        "peekOfCode": "target_metadata = Base.metadata  # use your models\n# Async run migrations\ndef run_migrations_online():\n    connectable = create_async_engine(config.get_main_option(\"sqlalchemy.url\"))\n    async def do_run_migrations():\n        async with connectable.connect() as connection:\n            await connection.run_sync(do_run_migrations_sync)\n    def do_run_migrations_sync(connection):\n        context.configure(connection=connection, target_metadata=target_metadata)\n        with context.begin_transaction():",
        "detail": "server.alembic.env",
        "documentation": {}
    },
    {
        "label": "UserCreate",
        "kind": 6,
        "importPath": "server.api.auth",
        "description": "server.api.auth",
        "peekOfCode": "class UserCreate(BaseModel):\n    username: str\n    password: str\n@auth_router.post(\"/auth/create\")\nasync def create_user(new_user: UserCreate, db: AsyncSession = Depends(get_db)):\n    # Hash password\n    hashed_password = pwd_context.hash(new_user.password)\n    # Create ORM object\n    user = User(username=new_user.username, password=hashed_password)\n    db.add(user)",
        "detail": "server.api.auth",
        "documentation": {}
    },
    {
        "label": "auth_router",
        "kind": 5,
        "importPath": "server.api.auth",
        "description": "server.api.auth",
        "peekOfCode": "auth_router = APIRouter()\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\nclass UserCreate(BaseModel):\n    username: str\n    password: str\n@auth_router.post(\"/auth/create\")\nasync def create_user(new_user: UserCreate, db: AsyncSession = Depends(get_db)):\n    # Hash password\n    hashed_password = pwd_context.hash(new_user.password)\n    # Create ORM object",
        "detail": "server.api.auth",
        "documentation": {}
    },
    {
        "label": "pwd_context",
        "kind": 5,
        "importPath": "server.api.auth",
        "description": "server.api.auth",
        "peekOfCode": "pwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\nclass UserCreate(BaseModel):\n    username: str\n    password: str\n@auth_router.post(\"/auth/create\")\nasync def create_user(new_user: UserCreate, db: AsyncSession = Depends(get_db)):\n    # Hash password\n    hashed_password = pwd_context.hash(new_user.password)\n    # Create ORM object\n    user = User(username=new_user.username, password=hashed_password)",
        "detail": "server.api.auth",
        "documentation": {}
    },
    {
        "label": "DATABASE_URL",
        "kind": 5,
        "importPath": "server.database.database",
        "description": "server.database.database",
        "peekOfCode": "DATABASE_URL = os.getenv(\"DATABASE_URL\")\n# Create async engine\nengine = create_async_engine(DATABASE_URL, echo=True)\n# Correct async session\nsyncSessionLocal = sessionmaker(\n    bind=engine,            # explicitly name the parameter\n    class_=AsyncSession,\n    expire_on_commit=False\n)\n# Base for models",
        "detail": "server.database.database",
        "documentation": {}
    },
    {
        "label": "engine",
        "kind": 5,
        "importPath": "server.database.database",
        "description": "server.database.database",
        "peekOfCode": "engine = create_async_engine(DATABASE_URL, echo=True)\n# Correct async session\nsyncSessionLocal = sessionmaker(\n    bind=engine,            # explicitly name the parameter\n    class_=AsyncSession,\n    expire_on_commit=False\n)\n# Base for models\nBase = declarative_base()",
        "detail": "server.database.database",
        "documentation": {}
    },
    {
        "label": "syncSessionLocal",
        "kind": 5,
        "importPath": "server.database.database",
        "description": "server.database.database",
        "peekOfCode": "syncSessionLocal = sessionmaker(\n    bind=engine,            # explicitly name the parameter\n    class_=AsyncSession,\n    expire_on_commit=False\n)\n# Base for models\nBase = declarative_base()",
        "detail": "server.database.database",
        "documentation": {}
    },
    {
        "label": "Base",
        "kind": 5,
        "importPath": "server.database.database",
        "description": "server.database.database",
        "peekOfCode": "Base = declarative_base()",
        "detail": "server.database.database",
        "documentation": {}
    },
    {
        "label": "User",
        "kind": 6,
        "importPath": "server.database.models",
        "description": "server.database.models",
        "peekOfCode": "class User(Base):\n    __tablename__=\"user\"\n    id=Column(UUID,primary_key=True,index=True,default=uuid.uuid4)\n    username=Column(String,nullable=False,unique=True)\n    password=Column(String,nullable=False)",
        "detail": "server.database.models",
        "documentation": {}
    },
    {
        "label": "escape",
        "kind": 2,
        "importPath": "server.env.bin.dumppdf",
        "description": "server.env.bin.dumppdf",
        "peekOfCode": "def escape(s: Union[str, bytes]) -> str:\n    if isinstance(s, bytes):\n        us = str(s, \"latin-1\")\n    else:\n        us = s\n    return ESC_PAT.sub(lambda m: \"&#%d;\" % ord(m.group(0)), us)\ndef dumpxml(out: TextIO, obj: object, codec: Optional[str] = None) -> None:\n    if obj is None:\n        out.write(\"<null />\")\n        return",
        "detail": "server.env.bin.dumppdf",
        "documentation": {}
    },
    {
        "label": "dumpxml",
        "kind": 2,
        "importPath": "server.env.bin.dumppdf",
        "description": "server.env.bin.dumppdf",
        "peekOfCode": "def dumpxml(out: TextIO, obj: object, codec: Optional[str] = None) -> None:\n    if obj is None:\n        out.write(\"<null />\")\n        return\n    if isinstance(obj, dict):\n        out.write('<dict size=\"%d\">\\n' % len(obj))\n        for k, v in obj.items():\n            out.write(\"<key>%s</key>\\n\" % k)\n            out.write(\"<value>\")\n            dumpxml(out, v)",
        "detail": "server.env.bin.dumppdf",
        "documentation": {}
    },
    {
        "label": "dumptrailers",
        "kind": 2,
        "importPath": "server.env.bin.dumppdf",
        "description": "server.env.bin.dumppdf",
        "peekOfCode": "def dumptrailers(\n    out: TextIO,\n    doc: PDFDocument,\n    show_fallback_xref: bool = False,\n) -> None:\n    for xref in doc.xrefs:\n        if not isinstance(xref, PDFXRefFallback) or show_fallback_xref:\n            out.write(\"<trailer>\\n\")\n            dumpxml(out, xref.get_trailer())\n            out.write(\"\\n</trailer>\\n\\n\")",
        "detail": "server.env.bin.dumppdf",
        "documentation": {}
    },
    {
        "label": "dumpallobjs",
        "kind": 2,
        "importPath": "server.env.bin.dumppdf",
        "description": "server.env.bin.dumppdf",
        "peekOfCode": "def dumpallobjs(\n    out: TextIO,\n    doc: PDFDocument,\n    codec: Optional[str] = None,\n    show_fallback_xref: bool = False,\n) -> None:\n    visited = set()\n    out.write(\"<pdf>\")\n    for xref in doc.xrefs:\n        for objid in xref.get_objids():",
        "detail": "server.env.bin.dumppdf",
        "documentation": {}
    },
    {
        "label": "dumpoutline",
        "kind": 2,
        "importPath": "server.env.bin.dumppdf",
        "description": "server.env.bin.dumppdf",
        "peekOfCode": "def dumpoutline(\n    outfp: TextIO,\n    fname: str,\n    objids: Any,\n    pagenos: Container[int],\n    password: str = \"\",\n    dumpall: bool = False,\n    codec: Optional[str] = None,\n    extractdir: Optional[str] = None,\n) -> None:",
        "detail": "server.env.bin.dumppdf",
        "documentation": {}
    },
    {
        "label": "extractembedded",
        "kind": 2,
        "importPath": "server.env.bin.dumppdf",
        "description": "server.env.bin.dumppdf",
        "peekOfCode": "def extractembedded(fname: str, password: str, extractdir: str) -> None:\n    def extract1(objid: int, obj: Dict[str, Any]) -> None:\n        filename = os.path.basename(obj.get(\"UF\") or cast(bytes, obj.get(\"F\")).decode())\n        fileref = obj[\"EF\"].get(\"UF\") or obj[\"EF\"].get(\"F\")\n        fileobj = doc.getobj(fileref.objid)\n        if not isinstance(fileobj, PDFStream):\n            error_msg = (\n                \"unable to process PDF: reference for %r is not a \"\n                \"PDFStream\" % filename\n            )",
        "detail": "server.env.bin.dumppdf",
        "documentation": {}
    },
    {
        "label": "dumppdf",
        "kind": 2,
        "importPath": "server.env.bin.dumppdf",
        "description": "server.env.bin.dumppdf",
        "peekOfCode": "def dumppdf(\n    outfp: TextIO,\n    fname: str,\n    objids: Iterable[int],\n    pagenos: Container[int],\n    password: str = \"\",\n    dumpall: bool = False,\n    codec: Optional[str] = None,\n    extractdir: Optional[str] = None,\n    show_fallback_xref: bool = False,",
        "detail": "server.env.bin.dumppdf",
        "documentation": {}
    },
    {
        "label": "create_parser",
        "kind": 2,
        "importPath": "server.env.bin.dumppdf",
        "description": "server.env.bin.dumppdf",
        "peekOfCode": "def create_parser() -> ArgumentParser:\n    parser = ArgumentParser(description=__doc__, add_help=True)\n    parser.add_argument(\n        \"files\",\n        type=str,\n        default=None,\n        nargs=\"+\",\n        help=\"One or more paths to PDF files.\",\n    )\n    parser.add_argument(",
        "detail": "server.env.bin.dumppdf",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "server.env.bin.dumppdf",
        "description": "server.env.bin.dumppdf",
        "peekOfCode": "def main(argv: Optional[List[str]] = None) -> None:\n    parser = create_parser()\n    args = parser.parse_args(args=argv)\n    if args.debug:\n        logging.getLogger().setLevel(logging.DEBUG)\n    if args.outfile == \"-\":\n        outfp = sys.stdout\n    else:\n        outfp = open(args.outfile, \"w\")\n    if args.objects:",
        "detail": "server.env.bin.dumppdf",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "server.env.bin.dumppdf",
        "description": "server.env.bin.dumppdf",
        "peekOfCode": "logger = logging.getLogger(__name__)\nESC_PAT = re.compile(r'[\\000-\\037&<>()\"\\042\\047\\134\\177-\\377]')\ndef escape(s: Union[str, bytes]) -> str:\n    if isinstance(s, bytes):\n        us = str(s, \"latin-1\")\n    else:\n        us = s\n    return ESC_PAT.sub(lambda m: \"&#%d;\" % ord(m.group(0)), us)\ndef dumpxml(out: TextIO, obj: object, codec: Optional[str] = None) -> None:\n    if obj is None:",
        "detail": "server.env.bin.dumppdf",
        "documentation": {}
    },
    {
        "label": "ESC_PAT",
        "kind": 5,
        "importPath": "server.env.bin.dumppdf",
        "description": "server.env.bin.dumppdf",
        "peekOfCode": "ESC_PAT = re.compile(r'[\\000-\\037&<>()\"\\042\\047\\134\\177-\\377]')\ndef escape(s: Union[str, bytes]) -> str:\n    if isinstance(s, bytes):\n        us = str(s, \"latin-1\")\n    else:\n        us = s\n    return ESC_PAT.sub(lambda m: \"&#%d;\" % ord(m.group(0)), us)\ndef dumpxml(out: TextIO, obj: object, codec: Optional[str] = None) -> None:\n    if obj is None:\n        out.write(\"<null />\")",
        "detail": "server.env.bin.dumppdf",
        "documentation": {}
    },
    {
        "label": "LITERAL_FILESPEC",
        "kind": 5,
        "importPath": "server.env.bin.dumppdf",
        "description": "server.env.bin.dumppdf",
        "peekOfCode": "LITERAL_FILESPEC = LIT(\"Filespec\")\nLITERAL_EMBEDDEDFILE = LIT(\"EmbeddedFile\")\ndef extractembedded(fname: str, password: str, extractdir: str) -> None:\n    def extract1(objid: int, obj: Dict[str, Any]) -> None:\n        filename = os.path.basename(obj.get(\"UF\") or cast(bytes, obj.get(\"F\")).decode())\n        fileref = obj[\"EF\"].get(\"UF\") or obj[\"EF\"].get(\"F\")\n        fileobj = doc.getobj(fileref.objid)\n        if not isinstance(fileobj, PDFStream):\n            error_msg = (\n                \"unable to process PDF: reference for %r is not a \"",
        "detail": "server.env.bin.dumppdf",
        "documentation": {}
    },
    {
        "label": "LITERAL_EMBEDDEDFILE",
        "kind": 5,
        "importPath": "server.env.bin.dumppdf",
        "description": "server.env.bin.dumppdf",
        "peekOfCode": "LITERAL_EMBEDDEDFILE = LIT(\"EmbeddedFile\")\ndef extractembedded(fname: str, password: str, extractdir: str) -> None:\n    def extract1(objid: int, obj: Dict[str, Any]) -> None:\n        filename = os.path.basename(obj.get(\"UF\") or cast(bytes, obj.get(\"F\")).decode())\n        fileref = obj[\"EF\"].get(\"UF\") or obj[\"EF\"].get(\"F\")\n        fileobj = doc.getobj(fileref.objid)\n        if not isinstance(fileobj, PDFStream):\n            error_msg = (\n                \"unable to process PDF: reference for %r is not a \"\n                \"PDFStream\" % filename",
        "detail": "server.env.bin.dumppdf",
        "documentation": {}
    },
    {
        "label": "float_or_disabled",
        "kind": 2,
        "importPath": "server.env.bin.pdf2txt",
        "description": "server.env.bin.pdf2txt",
        "peekOfCode": "def float_or_disabled(x: str) -> Optional[float]:\n    if x.lower().strip() == \"disabled\":\n        return None\n    try:\n        return float(x)\n    except ValueError:\n        raise argparse.ArgumentTypeError(f\"invalid float value: {x}\")\ndef extract_text(\n    files: Iterable[str] = [],\n    outfile: str = \"-\",",
        "detail": "server.env.bin.pdf2txt",
        "documentation": {}
    },
    {
        "label": "extract_text",
        "kind": 2,
        "importPath": "server.env.bin.pdf2txt",
        "description": "server.env.bin.pdf2txt",
        "peekOfCode": "def extract_text(\n    files: Iterable[str] = [],\n    outfile: str = \"-\",\n    laparams: Optional[LAParams] = None,\n    output_type: str = \"text\",\n    codec: str = \"utf-8\",\n    strip_control: bool = False,\n    maxpages: int = 0,\n    page_numbers: Optional[Container[int]] = None,\n    password: str = \"\",",
        "detail": "server.env.bin.pdf2txt",
        "documentation": {}
    },
    {
        "label": "create_parser",
        "kind": 2,
        "importPath": "server.env.bin.pdf2txt",
        "description": "server.env.bin.pdf2txt",
        "peekOfCode": "def create_parser() -> argparse.ArgumentParser:\n    parser = argparse.ArgumentParser(description=__doc__, add_help=True)\n    parser.add_argument(\n        \"files\",\n        type=str,\n        default=None,\n        nargs=\"+\",\n        help=\"One or more paths to PDF files.\",\n    )\n    parser.add_argument(",
        "detail": "server.env.bin.pdf2txt",
        "documentation": {}
    },
    {
        "label": "parse_args",
        "kind": 2,
        "importPath": "server.env.bin.pdf2txt",
        "description": "server.env.bin.pdf2txt",
        "peekOfCode": "def parse_args(args: Optional[List[str]]) -> argparse.Namespace:\n    parsed_args = create_parser().parse_args(args=args)\n    # Propagate parsed layout parameters to LAParams object\n    if parsed_args.no_laparams:\n        parsed_args.laparams = None\n    else:\n        parsed_args.laparams = LAParams(\n            line_overlap=parsed_args.line_overlap,\n            char_margin=parsed_args.char_margin,\n            line_margin=parsed_args.line_margin,",
        "detail": "server.env.bin.pdf2txt",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "server.env.bin.pdf2txt",
        "description": "server.env.bin.pdf2txt",
        "peekOfCode": "def main(args: Optional[List[str]] = None) -> int:\n    parsed_args = parse_args(args)\n    outfp = extract_text(**vars(parsed_args))\n    outfp.close()\n    return 0\nif __name__ == \"__main__\":\n    sys.exit(main())",
        "detail": "server.env.bin.pdf2txt",
        "documentation": {}
    },
    {
        "label": "OUTPUT_TYPES",
        "kind": 5,
        "importPath": "server.env.bin.pdf2txt",
        "description": "server.env.bin.pdf2txt",
        "peekOfCode": "OUTPUT_TYPES = ((\".htm\", \"html\"), (\".html\", \"html\"), (\".xml\", \"xml\"), (\".tag\", \"tag\"))\ndef float_or_disabled(x: str) -> Optional[float]:\n    if x.lower().strip() == \"disabled\":\n        return None\n    try:\n        return float(x)\n    except ValueError:\n        raise argparse.ArgumentTypeError(f\"invalid float value: {x}\")\ndef extract_text(\n    files: Iterable[str] = [],",
        "detail": "server.env.bin.pdf2txt",
        "documentation": {}
    },
    {
        "label": "cmd_doc",
        "kind": 5,
        "importPath": "server.env.bin.runxlrd",
        "description": "server.env.bin.runxlrd",
        "peekOfCode": "cmd_doc = \"\"\"\nCommands:\n2rows           Print the contents of first and last row in each sheet\n3rows           Print the contents of first, second and last row in each sheet\nbench           Same as \"show\", but doesn't print -- for profiling\nbiff_count[1]   Print a count of each type of BIFF record in the file\nbiff_dump[1]    Print a dump (char and hex) of the BIFF records in the file\nfonts           hdr + print a dump of all font objects\nhdr             Mini-overview of file (no per-sheet information)\nhotshot         Do a hotshot profile run e.g. ... -f1 hotshot bench bigfile*.xls",
        "detail": "server.env.bin.runxlrd",
        "documentation": {}
    },
    {
        "label": "options",
        "kind": 5,
        "importPath": "server.env.bin.runxlrd",
        "description": "server.env.bin.runxlrd",
        "peekOfCode": "options = None\nif __name__ == \"__main__\":\n    import xlrd\n    import sys\n    import time\n    import glob\n    import traceback\n    import gc\n    from xlrd.timemachine import xrange, REPR\n    class LogHandler(object):",
        "detail": "server.env.bin.runxlrd",
        "documentation": {}
    },
    {
        "label": "extract_file",
        "kind": 2,
        "importPath": "server.env.bin.vba_extract",
        "description": "server.env.bin.vba_extract",
        "peekOfCode": "def extract_file(xlsm_zip, filename):\n    # Extract a single file from an Excel xlsm macro file.\n    data = xlsm_zip.read(\"xl/\" + filename)\n    # Write the data to a local file.\n    file = open(filename, \"wb\")\n    file.write(data)\n    file.close()\n# The VBA project file and project signature file we want to extract.\nvba_filename = \"vbaProject.bin\"\nvba_signature_filename = \"vbaProjectSignature.bin\"",
        "detail": "server.env.bin.vba_extract",
        "documentation": {}
    },
    {
        "label": "vba_filename",
        "kind": 5,
        "importPath": "server.env.bin.vba_extract",
        "description": "server.env.bin.vba_extract",
        "peekOfCode": "vba_filename = \"vbaProject.bin\"\nvba_signature_filename = \"vbaProjectSignature.bin\"\n# Get the xlsm file name from the commandline.\nif len(sys.argv) > 1:\n    xlsm_file = sys.argv[1]\nelse:\n    print(\n        \"\\nUtility to extract a vbaProject.bin binary from an Excel 2007+ \"\n        \"xlsm macro file for insertion into an XlsxWriter file.\\n\"\n        \"If the macros are digitally signed, extracts also a vbaProjectSignature.bin \"",
        "detail": "server.env.bin.vba_extract",
        "documentation": {}
    },
    {
        "label": "vba_signature_filename",
        "kind": 5,
        "importPath": "server.env.bin.vba_extract",
        "description": "server.env.bin.vba_extract",
        "peekOfCode": "vba_signature_filename = \"vbaProjectSignature.bin\"\n# Get the xlsm file name from the commandline.\nif len(sys.argv) > 1:\n    xlsm_file = sys.argv[1]\nelse:\n    print(\n        \"\\nUtility to extract a vbaProject.bin binary from an Excel 2007+ \"\n        \"xlsm macro file for insertion into an XlsxWriter file.\\n\"\n        \"If the macros are digitally signed, extracts also a vbaProjectSignature.bin \"\n        \"file.\\n\"",
        "detail": "server.env.bin.vba_extract",
        "documentation": {}
    }
]